==========================================================
============== Number.prototype.toString() ===============
==========================================================
Метод toString() возвращает строковое представление указанного объекта Number.

Синтаксис
numObj.toString([radix])

Параметры
radix
Необязательный параметр. Целое число между 2 и 36, определяющее основание системы счисления, используемой для представления числового значения.

var count = 10;

console.log(count.toString());    // Выведет '10'
console.log((17).toString());     // Выведет '17'

var x = 6;

console.log(x.toString(2));       // Выведет '110'
console.log((254).toString(16));  // Выведет 'fe'

console.log((-10).toString(2));   // Выведет '-1010'
console.log((-0xff).toString(2)); // Выведет '-11111111'

==========================================================
============== parseInt() ===============
==========================================================
Функция parseInt() принимает строку в качестве аргумента и возвращает целое число в соответствии с указанным основанием системы счисления.

parseInt(string, radix);
Параметры
string
Значение, которое необходимо проинтерпретировать. Если значение параметра string не принадлежит строковому типу, оно преобразуется в него (с помощью абстрактной операции ToString). Пробелы в начале строки не учитываются.

radix
Целое число в диапазоне между 2 и 36, представляющее собой основание системы счисления числовой строки string, описанной выше. В основном пользователи используют десятичную систему счисления и указывают 10. Всегда указывайте этот параметр, чтобы исключить ошибки считывания и гарантировать корректность исполнения и предсказуемость результата. Когда основание системы счисления не указано, разные реализации могут возвращать разные результаты.

Возвращаемое значение
Целое число, полученное парсингом (разбором и интерпретацией) переданной строки. Если первый символ не получилось сконвертировать в число, то возвращается NaN.

Все следующие примеры возвращают 15:

parseInt(" 0xF", 16);
parseInt(" F", 16);
parseInt("17", 8);
parseInt(021, 8);
parseInt("015", 10);  //parseInt(015, 10); вернёт 15
parseInt(15.99, 10);
parseInt("FXX123", 16);
parseInt("1111", 2);
parseInt("15*3", 10);
parseInt("15e2", 10);
parseInt("15px", 10);
parseInt("12", 13);

==========================================================
============== parseFloat() ===============
==========================================================
Функция parseFloat() принимает строку в качестве аргумента и возвращает десятичное число (число с плавающей точкой)

parseFloat(строка)
Параметры
строка
Текстовая строка, из которой вам надо выделить десятичное число.

Возвращаемое значение
Число с плавающей точкой, полученное из строки. Если первый символ не может быть сконвертирован в число, то возвращается NaN.

Описание
parseFloat - это высокоуровневая функция, не привязанная ни к одному объекту.

parseFloat разбирает текстовую строку, ищет и возвращает из неё десятичное число. Если функция встретит знак, отличный от (+ или -), цифр(0-9), разделительной точки, или показателя степени, она вернёт значение, предшествующее этому знаку, игнорируя все последующие символы . Допускаются позади и впереди идущие пробелы.

Если первый символ нельзя привести к числовому виду, parseFloat вернёт NaN.

Все примеры ниже вернут 3.14

parseFloat(3.14);
parseFloat('3.14');
parseFloat('314e-2');
parseFloat('0.0314E+2');
parseFloat('3.14какие-нибудь не цифровые знаки');

var foo = Object.create(null);
foo.toString = function () { return "3.14"; };
parseFloat(foo);

var foo = Object.create(null);
foo.valueOf = function () { return "3.14"; };
parseFloat(foo);​​​​​

=====================================================
=============== Number.isInteger() ==================
=====================================================

Метод Number.isInteger() определяет, является ли переданное значение целым числом.

function fits(x, y) {
  if (Number.isInteger(y / x)) {
    return 'Fits!';
  }
  return 'Does NOT fit!';
}

console.log(fits(5, 10));
// expected output: "Fits!"

console.log(fits(5, 11));
// expected output: "Does NOT fit!"

==================================================
================= Number.isFinite() ==============
==================================================

Метод Number.isFinite() определяет, является ли переданное значение конечным числом.
В отличии от глобальной функции isFinite(), этот метод принудительно не преобразует параметр в число. Это означает, что он возвращает true только для конечных значений числового типа.

Number.isFinite(Infinity);  // false
Number.isFinite(NaN);       // false
Number.isFinite(-Infinity); // false

Number.isFinite(0);         // true
Number.isFinite(2e64);      // true

Number.isFinite('0');       // false, при использовании глобальной
                            // функции isFinite('0') было бы true

=================================================
================== Number.isNaN() ===============
=================================================

Метод Number.isNaN() определяет, является ли переданное значение NaN. Это более надёжная версия оригинальной глобальной функции isNaN().
Поскольку оба оператора проверки на равенство, == (en-US) и === (en-US), вычисляются в false при проверке, что NaN и есть NaN, появляется необходимость в функции Number.isNaN(). Эта ситуация отличается от всех других возможных сравнений в JavaScript.

В отличие от глобальной функции isNaN(), Number.isNaN() не имеет проблемы принудительного преобразования параметра в число. Это значит, что в него безопасно передавать значения, которые обычно превращаются в NaN, но на самом деле NaN не являются. Также это значит, что метод возвращает true только для числовых значений, имеющих значение NaN.

umber.isNaN(NaN); // true
Number.isNaN(Number.NaN); // true
Number.isNaN(0 / 0) // true

// При использовании глобальной функции isNaN() это всё будет true
Number.isNaN('NaN');      // false
Number.isNaN(undefined);  // false
Number.isNaN({});         // false
Number.isNaN('blabla');   // false

// А это всё в любом случае будет false
Number.isNaN(true);
Number.isNaN(null);
Number.isNaN(37);
Number.isNaN('37');
Number.isNaN('37.37');
Number.isNaN('');
Number.isNaN(' ');

====================================================
============ Number.isSafeInteger() ================
====================================================

Метод Number.isSafeInteger() определяет, является ли переданное значение безопасным целым числом.

function warn(x) {
  if (Number.isSafeInteger(x)) {
    return 'Precision safe.';
  }
  return 'Precision may be lost!';
}

console.log(warn(Math.pow(2, 53)));
// expected output: "Precision may be lost!"

console.log(warn(Math.pow(2, 53) - 1));
// expected output: "Precision safe."

=====================================================

Сложение чисел с плавающей точкой
При сложении не целых чисел в JavaScript и других языках программирования, есть особенность. Если кратко, то 0.1 + 0.2 не равно 0.3, результат сложения больше чем 0.3. Все от того что машина считает в двоичной системе.

Число 0.1 в двоичной системе счисления - это бесконечная дробь, так как единица на десять в двоичной системе не делится. Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. При сложении 0.1 и 0.2, две неточности складываются, получается незначительная, но всё же ошибка в вычислениях.

console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004

Конечно, это не означает, что точные вычисления для таких чисел невозможны. Есть несколько методов решения этой проблемы.

Можно сделать их целыми, умножив на N, сложить, а потом результат разделить также на N.

console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 * 100 + 0.24 * 100) / 100); // 0.41

Еще один способ - сложить, а результат отсечь до определённого знака после запятой при помощи метода toFixed().

console.log(0.17 + 0.24); // 0.41000000000000003
console.log((0.17 + 0.24).toFixed(2)); // 0.41

# ======== Класс Math =========
Один из встроенных классов, который предоставляет набор методов для работы с числами. Знание всех методов наизусть не требуется, только некоторых, наиболее полезных.

// Math.floor(num) - возвращает наибольшее целое число,
// меньшее, либо равное указанному
console.log(Math.floor(1.7)); // 1

// Math.ceil(num) - возвращает наименьшее целое число,
// большее, либо равное указанному числу.
console.log(Math.ceil(1.2)); // 2

// Math.round(num) - возвращает значение числа,
// округлённое до ближайшего целого
console.log(Math.round(1.2)); // 1
console.log(Math.round(1.5)); // 2

// Math.max(num1, num2, ...) - возвращает наибольшее число из набора
console.log(Math.max(20, 10, 50, 40)); // 50

// Math.min(num1, num2, ...) - возвращает наименьшее число из набора
console.log(Math.min(20, 10, 50, 40)); // 10

// Math.pow(base, exponent) - возведение в степень
console.log(Math.pow(2, 4)); // 16

// Math.random() - возвращает псевдослучайное число в диапазоне [0, 1)
console.log(Math.random()); // случайное число между 0 и 1
console.log(Math.random() * (10 - 1) + 1); // псевдослучайное число от 1 до 10

// Math.hypot() - Метод Math.hypot() возвращает квадратный корень суммы квадратов своих аргументов.
Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755

# ========== Number.EPSILON ===========
Очень маленькое число, которое решает проблему корректного округления чисел:

let num = 1.005 + Number.EPSILON; 
let num2 = Math.round(num * 100) / 100; // 1.01

console.log(num *100); // 100.5000000000001
console.log(Math.round(num * 100)); // 101
==========================================================
============== toFixed() ===== toPrecision() ===============
Эти методы используются для конвертации числа в число с указанной точностью.
toFixed() числа после запятой, toPrecision() включая цифры перед запятой. 
Методы возвращают полученное значение в виде строки.

var x = 9.656;
var newX = x.toPrecision(2); 
console.log(newX) // '9.7'
var newX = x.toPrecision(4);  
console.log(newX) // '9.656'
var newX = x.toPrecision(6);  
console.log(newX) // '9.65600'
==========================================================


==========================================================
==============  ===============
==========================================================


==========================================================
==============  ===============
==========================================================


==========================================================
==============  ===============
==========================================================


==========================================================
==============  ===============
==========================================================


==========================================================
==============  ===============
==========================================================


==========================================================
==============  ===============
==========================================================