# =========== Методы массива ==========

================================================
=========== Методы split() и join() ============
================================================

Метод split(delimiter) превращает строку в массив, «разбив» её по разделителю delimiter. Если разделитель это пустая строка, то получится массив отдельных символов. Разделителем может быть один или несколько символов.

const name = "Mango";
console.log(name.split("")); // ["M", "a", "n", "g", "o"]

const message = "JavaScript это интересно";
console.log(message.split(" ")); // ["JavaScript", "это", "интересно"]

Метод массивов join(delimiter) соединяет элементы массива в строку. В строке элементы будут разделены символом или группой символов указанных в delimiter. То есть это операция обратная методу строк split(delimiter).

const words = ["JavaScript", "это", "интересно"];
console.log(words.join("")); // "JavaScriptэтоинтересно"
console.log(words.join(" ")); // "JavaScript это интересно"
console.log(words.join("-")); // "JavaScript-это-интересно"


===================================================
================ Метод indexOf() ==================
===================================================

indexOf(value) возвращает первый индекс, в котором элемент со значением value был найден в массиве, или число -1, если такого элемента нет. Используйте indexOf тогда, когда необходимо получить непосредственно индекс элемента.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.indexOf("Poly")); // 2
console.log(clients.indexOf("Monkong")); // -1


===================================================
================ Метод includes() =================
===================================================

includes(value) проверяет есть ли в массиве элемент со значением value и возвращает true или false соответственно. Область применения этого метода сводится к ситуациям когда необходимо проверить есть ли элемент в массиве и не важна его позиция (индекс).

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.includes("Poly")); // true
console.log(clients.includes("Monkong")); // false

Проверка множественных условий с includes()
На первый взгляд код следующего примера выглядит хорошо.

const fruit = "apple";

if (fruit === "apple" || fruit === "strawberry") {
  console.log("It is a red fruit!");
}

Однако, что если у нас будет больше красных фруктов, к примеру ещё вишня (cherry) или клюква (cranberries)? Будем ли мы расширять условие с помощью дополнительных ||?

const fruit = "apple";

if (
  fruit === "apple" ||
  fruit === "strawberry" ||
  fruit === "cherry" ||
  fruit === "cranberries"
) {
  console.log("It is a red fruit!");
}

Можем переписать условие используя метод includes(), это очень просто и масштабируемо.

// Выносим варианты в массив
const redFruits = ["apple", "strawberry", "cherry", "cranberries"];
const fruit = "cherry";
// Проверяем наличие элемента
const hasFruit = redFruits.includes(fruit);

if (hasFruit) {
  console.log(`${fruit} is a red fruit!`);
}


=========================================================
================ Методы push() и pop() ==================
=========================================================

Добавляют или удаляют крайние элементы массива. Работают только с крайним левым и крайним правым элементом и не могут поставить или удалить элемент с произвольной позиции.

Метод push() добавляет один или несколько элементов в конец массива, без необходимости указывать индексы добавляемых элементов. Возвращает длину массива после добавления элементов.

const numbers = [];

numbers.push(1, 2, 5);

console.log(numbers.push()); // 3 (длина массива)
console.log(numbers); // [1, 2, 5]

Метод pop() удаляет последний элемент из конца массива и возвращает удаленный элемент. Если массив пустой, метод возвращает undefined.

pop method
const numbers = [1, 2, 3, 4, 5];

console.log(numbers.pop()); //  5
console.log(numbers); // [1, 2, 3, 4]

console.log(numbers.pop()); //  4
console.log(numbers); // [1, 2, 3]

console.log(numbers.pop()); //  3
console.log(numbers); // [1, 2]

console.log(numbers.pop()); //  2
console.log(numbers); // [1]

console.log(numbers.pop()); //  1
console.log(numbers); // []


==========================================================
=============== Методы .shift() и .unshift() =============
==========================================================

 Методы .shift() удаляет элемент из начала массива, .unshift() добавляет элемент в начало массива
// const array = [1, 2, 3, 4, 5];

// const firstEl = array.shift();

// console.log(array);
// console.log(firstEl);

/* --------- */

// const array = [1, 2, 3, 4, 5];

// array.unshift(8);

// console.log(array);

/* --------- */

// const array = [1, 2, 3, 4, 5];

// const newArray = array.concat([[1]], [['STR']]);

// newArray.shift();

// console.log(array);
// console.log(newArray);

===============================================
=============== Метод slice() =================
===============================================

slice(begin, end) возвращает новый массив, содержащий копию части исходного массива, не изменяя его. Копия делается от begin и до, но не включая, end - индексы элементов исходного массива.

slice method
const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1, 3)); // ["Ajax", "Poly"]

Если begin и end не указаны, будет создана полная копия исходного массива.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice()); // ["Mango", Ajax", "Poly", "Kiwi"]

Если не указан end, копирование будет от start и до конца исходного массива.

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(1)); // ["Ajax", "Poly", "Kiwi"]
console.log(clients.slice(2)); // ["Poly", "Kiwi"]

Если значение start отрицательное, а end не указан, то будут скопированы последние start элементов

const clients = ["Mango", "Ajax", "Poly", "Kiwi"];
console.log(clients.slice(-2)); // ["Poly", "Kiwi"]

=========================================================
==================== Метод toSpliced() ==================
=========================================================
Метод toSpliced()экземпляров Arrayявляется копирующей версией метода splice(). Он возвращает новый массив с некоторыми удаленными и/или замененными элементами по заданному индексу.

const months = ["Jan", "Mar", "Apr", "May"];

// Inserting an element at index 1
const months2 = months.toSpliced(1, 0, "Feb");
console.log(months2); // ["Jan", "Feb", "Mar", "Apr", "May"]

// Deleting two elements starting from index 2
const months3 = months2.toSpliced(2, 2);
console.log(months3); // ["Jan", "Feb", "May"]

// Replacing one element at index 1 with two new elements
const months4 = months3.toSpliced(1, 1, "Feb", "Mar");
console.log(months4); // ["Jan", "Feb", "Mar", "May"]

// Original array is not modified
console.log(months); // ["Jan", "Mar", "Apr", "May"]

=========================================================
==================== Метод splice() =====================
=========================================================

Швейцарский нож для работы с массивами, если исходный массив нужно изменить. Удаляет, добавляет и заменяет элементы в произвольном месте массива.

# Удаление
Чтобы удалить элементы в массиве, передаются два аргумента.

splice(position, num)

position - указывает позицию (индекс) первого элемента для удаления
num - определяет количество удаляемых элементов
Метод splice изменяет исходный массив и возвращает массив, содержащий удаленные элементы. Например, у нас есть массив оценок, который содержит пять чисел от 1 до 5.

const scores = [1, 2, 3, 4, 5];

// Удаляем три элемента массива, начиная с первого элемента (индекс 0)
const deletedScores = scores.splice(0, 3);

// Теперь массив scores содержит два элемента
console.log(scores); // [4, 5]

// А массив deletedScores содержит три удаленных элемента
console.log(deletedScores); // [1, 2, 3]


ИНТЕРЕСНО
На практике возращаемое значение (массив удалённых элементов) используется редко. В основном просто необходимо удалить элементы из массива.

# Добавление
Для того чтобы добавить один или несколько элементов в массив, необходимо передать три или более аргумента, при этом второй аргумент должен быть равен нулю.

splice(position, 0, new_element_1, new_element_2, ...)

Аргумент position указывает начальную позицию в массиве, куда будут вставлены новые элементы.
Второй аргумент это ноль, он говорит методу не удалять элементы в месте добавления новых.
Третий, четвертый и все последующие аргументы - это новые элементы, которые добавляются в массив.
Например, у нас есть массив с названиями цветов в виде строк. Добавим новый цвет перед элементом с индексом 2.

const colors = ["red", "green", "blue"];

colors.splice(2, 0, "purple");
console.log(colors); // ["red", "green", "purple", "blue"]

На рисунке показан вызов метода colors.splice(2, 0, 'purple') из примера.

splice insert
Можно добавить произвольное количество элементов, передав четвертый, пятый аргумент и т. д.

const colors = ["red", "green", "blue"];

colors.splice(1, 0, "yellow", "pink");
console.log(colors); // ["red", "yellow", "pink", "green", "blue"]

# Замена
Замена это операция добавления в которой удаляются элементы в месте добавления новых. Для этого необходимо передать минимум три аргумента. Количество удаляемых и добавляемых элементов может не совпадать.

splice(position, num, new_element_1, new_element_2, ...)

position - указывает позицию (индекс) первого элемента для удаления
num - определяет количество удаляемых элементов
Третий, четвертый и все последующие аргументы - это новые элементы, которые добавляются в массив.
например, у нас есть массив языков программирования из четырех элементов.

const languages = ["C", "C++", "Java", "JavaScript"];

// Заменяем элемент с индексом 1 на новый
languages.splice(1, 1, "Python");
console.log(languages); // ["C", "Python", "Java", "JavaScript"]

// Заменяем один элемент (с индексом 2) на несколько
languages.splice(2, 1, "C#", "Swift", "Go");
console.log(languages); // ["C", "Python", "C#", "Swift", "Go", "JavaScript"]


====================================================
================= Метод concat() ===================
====================================================

Объединяет два или более массива в один. Он не изменяет массив на котором вызывается, а возвращает новый. Порядок аргументов метода влияет на порядок элементов нового массива.

const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"];
const newClients = ["Monkong", "Singu"];

const allClientsWithOldFirst = oldClients.concat(newClients);
console.log(allClientsWithOldFirst); // ["Mango", "Ajax", "Poly", "Kiwi", "Monkong", "Singu"]

const allClientsWithNewFirst = newClients.concat(oldClients);
console.log(allClientsWithNewFirst); // ["Monkong", "Singu", "Mango", "Ajax", "Poly", "Kiwi"]

console.log(oldClients); // ["Mango", "Ajax", "Poly", "Kiwi"]
console.log(newClients); // ["Monkong", "Singu"]


=====================================================
=================== Метод reverse() =================
=====================================================

Разворачивает массив.

const numbers = [1, 2, 3, 4, 5, 6, 7];
numbers.reverse() // [7, 6, 5, 4, 3, 2, 1];

=====================================================
=================== Метод toReversed() ==============
=====================================================
Метод toReversed()экземпляров Array является копирующим аналогом метода reverse(). 
Он возвращает новый массив с элементами в обратном порядке.

const items = [1, 2, 3];
console.log(items); // [1, 2, 3]

const reversedItems = items.toReversed();
console.log(reversedItems); // [3, 2, 1]
console.log(items); // [1, 2, 3]


==========================================================================
========================= Фильтр уникальных значений =====================
==========================================================================
Тип Set был введен в ES6, и наряду с оператором «spread» ... мы можем использовать его для создания нового массива с уникальными значениями.

const array = [1, 1, 2, 3, 5, 5, 1]
const uniqueArray = [...new Set(array)]; // [1, 2, 3, 4, 5]

До ES6 фильтрация уникальных значений потребовала бы гораздо больше кода, чем сейчас!

Этот трюк работает для массивов, содержащих примитивные типы: undefined, null, boolean, string и number. (Если бы у вас был массив, содержащий объекты, функции или дополнительные массивы, вам понадобился бы другой подход!)

==========================================================================
========================= Метод массива from()  ==========================
==========================================================================
Метод Array.from() создаёт новый экземпляр Array из массивоподобного или итерируемого объекта.

Array.from() позволяет вам создавать массивы из:
- массивоподобных объектов (объектов со свойством length и элементами по индексным ключам) или
- итерируемых объектов (объектов, из которых вы можете достать их элементы, например Map или Set).

console.log(Array.from('foo')); // ['f', 'o', 'o']
console.log(Array.from([1, 2, 3], x => x + x)); // [2, 4, 6]

==========================================================================
========================= Метод массива .fill() ======================
==========================================================================
Метод fill() заполняет все элементы массива от начального до конечного индексов одним значением

arr.fill(value[, start = 0[, end = this.length]])

Параметры:

value
Значение, заполняющее массив.

start
Необязательный параметр. Начальный индекс.

end
Необязательный параметр. Конечный индекс.

Возвращаемое значение
Изменённый массив.

[1, 2, 3].fill(4);               // [4, 4, 4]
[1, 2, 3].fill(4, 1);            // [1, 4, 4]
[1, 2, 3].fill(4, 1, 2);         // [1, 4, 3]
[1, 2, 3].fill(4, 1, 1);         // [1, 2, 3]
[1, 2, 3].fill(4, 3, 3);         // [1, 2, 3]
[1, 2, 3].fill(4, -3, -2);       // [4, 2, 3]
[1, 2, 3].fill(4, NaN, NaN);     // [1, 2, 3]
[1, 2, 3].fill(4, 3, 5);         // [1, 2, 3]
Array(3).fill(4);                // [4, 4, 4]
[].fill.call({ length: 3 }, 4);  // {0: 4, 1: 4, 2: 4, length: 3}

// Объекты заполняются по ссылке.
var arr = Array(3).fill({}) // [{}, {}, {}];
arr[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]

==========================================================================
========================= Array.prototype.with() =========================
==========================================================================
Метод with()экземпляров Array— это копирующая версия использования нотации скобок для изменения значения заданного индекса. Он возвращает новый массив с элементом по заданному индексу, замененным заданным значением.

Синтаксис
array.with(index, value)
Скопировать в буфер обмена
Параметры
index
Отсчитываемый от нуля индекс, по которому следует изменить массив, преобразованный в целое число .

Отрицательный индекс отсчитывается от конца массива — если используется , index < 0.index + array.length
Если индекс после нормализации выходит за пределы, RangeErrorвыбрасывается a.
value
Любое значение, которое будет присвоено данному индексу.

Возвращаемое значение
Новый массив, в котором элемент at indexзаменен на value.

Исключения
RangeError
Выброшено, если index >= array.lengthили index < -array.length.

const arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6)); // [1, 2, 6, 4, 5]
console.log(arr); // [1, 2, 3, 4, 5]

const arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6).map((x) => x ** 2)); // [1, 4, 36, 16, 25]

const arr = [1, , 3, 4, , 6];
console.log(arr.with(0, 2)); // [2, undefined, 3, 4, undefined, 6]

const arrayLike = {
  length: 3,
  unrelated: "foo",
  0: 5,
  2: 4,
};
console.log(Array.prototype.with.call(arrayLike, 0, 1));
// [ 1, undefined, 4 ]


==========================================================================
========================= flatMap() ======================
==========================================================================
Метод flatMap()экземпляров Arrayвозвращает новый массив, сформированный путем применения заданной функции обратного вызова к каждому элементу массива, а затем выравнивания результата на один уровень. Он идентичен a, map()за которым следует a flat()глубины 1 ( arr.map(...args).flat()), но немного более эффективен, чем вызов этих двух методов по отдельности.

const arr1 = [1, 2, 1];

const result = arr1.flatMap((num) => (num === 2 ? [2, 2] : 1));

console.log(result);
// Expected output: Array [1, 2, 2, 1]

==========================================================================
========================= flat() ======================
==========================================================================
Метод flat()экземпляров Arrayсоздает новый массив со всеми элементами подмассива, рекурсивно объединенными в него до указанной глубины.

const arr1 = [0, 1, 2, [3, 4]];

console.log(arr1.flat());
// expected output: Array [0, 1, 2, 3, 4]

const arr2 = [0, 1, [2, [3, [4, 5]]]];

console.log(arr2.flat());
// expected output: Array [0, 1, 2, Array [3, Array [4, 5]]]

console.log(arr2.flat(2));
// expected output: Array [0, 1, 2, 3, Array [4, 5]]

console.log(arr2.flat(Infinity));
// expected output: Array [0, 1, 2, 3, 4, 5]

==========================================================================
=========================  ======================
==========================================================================


==========================================================================
=========================  ======================
==========================================================================


==========================================================================
=========================  ======================
==========================================================================


==========================================================================
=========================  ======================
==========================================================================


==========================================================================
=========================  ======================
==========================================================================


==========================================================================
=========================  ======================
==========================================================================