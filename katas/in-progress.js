//? ----------------------------------------------------------
/*
5 kyu
Common Denominators

Общие знаменатели

У вас будет список рациональных чисел в виде

{ {numer_1, denom_1} , ... {numer_n, denom_n} } 
or
[ [numer_1, denom_1] , ... [numer_n, denom_n] ] 
or
[ (numer_1, denom_1) , ... (numer_n, denom_n) ] 
где все числа являются положительными целыми числами. 
Вы должны получить результат в виде:

(N_1, D) ... (N_n, D) 
or
[ [N_1, D] ... [N_n, D] ] 
or
[ (N_1', D) , ... (N_n, D) ] 
or
{{N_1, D} ... {N_n, D}} 
or
"(N_1, D) ... (N_n, D)"
в зависимости от языка (см. примеры тестов), в котором D как можно меньше и

N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.
Пример:
convertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]
Примечание:
В связи с тем, что первые переводы были написаны давно - более 6 лет 
- в этих первых переводах есть только несократимые дроби.

В более новых переводах есть некоторые сократимые дроби. 
Чтобы быть в безопасности, лучше проделать немного больше работы, упростив дроби, 
даже если это не обязательно.
*/

function convertFrac(lst) {}

// console.log(
//   convertFrac([
//     [1, 2],
//     [1, 3],
//     [1, 4],
//   ])
// ); // "(6,12)(4,12)(3,12)"

//? --------------------------------------------------------
/*
4 kyu Strings Mix

Учитывая две строки s1 и s2, мы хотим визуализировать, насколько они различаются. 
Мы будем учитывать только строчные буквы (от а до z). Сначала посчитаем частоту встречаемости каждой строчной буквы в s1 и s2.

s1 = "A aaaa bb c"

s2 = "& aaa bbb c d"

s1 has 4 'a', 2 'b', 1 'c'

s2 has 3 'a', 3 'b', 1 'c', 1 'd'

Таким образом, максимум для «a» в s1 и s2 равен 4 из s1; максимум для 'b' равен 3 от s2. 
В дальнейшем мы не будем рассматривать буквы, максимум их вхождений которых меньше или равен 1.

Мы можем возобновить различия между s1 и s2 в следующей строке: "1:aaaa/2:bbb" 
где 1 in 1:aaaa означает строку s1 и aaaa потому что максимум for aравен 4. 
Таким же образом 2:bbb обозначается строка s2 и bbb потому что максимум for bравен 3.

Задача состоит в том, чтобы создать строку, в которой каждая строчная буква s1 или s2 встречается столько раз, 
сколько ее максимум, если этот максимум строго больше 1 ; перед этими буквами будет стоять номер строки, 
в которой они встречаются, с максимальным значением и :. 
Если максимум находится в s1, а также в s2, префикс равен =:.

В результате подстроки (например, подстрока 2:nnnnn или 1:hhh; она содержит префикс) будут располагаться 
в порядке убывания своей длины, а при одинаковой длине - в возрастающем лексикографическом порядке 
(буквы и цифры - подробнее точно отсортировано по коду); разные группы будут разделены символом «/».
*/

function mix(s1, s2) {
  if (s1 === s2) return '';

  const obj1 = {};
  const obj2 = {};
  const lettersArr1 = s1.match(/[a-z]/g);
  const lettersArr2 = s2.match(/[a-z]/g);

  for (const el of s1) {
    if (lettersArr2.includes(el)) {
      if (!obj1[el]) obj1[el] = 0;
      obj1[el] += 1;
    }
  }

  for (const el of s2) {
    if (lettersArr1.includes(el)) {
      if (!obj2[el]) obj2[el] = 0;
      obj2[el] += 1;
    }
  }

  const sortLetters1 = new Array(
    ...Object.entries(obj1)
      .filter((el) => el[1] > 1)
      .sort((a, b) => b[1] - a[1])
  );
  const sortLetters2 = new Array(
    ...Object.entries(obj2)
      .filter((el) => el[1] > 1)
      .sort((a, b) => b[1] - a[1])
  );

  let result = '';

  //   for (let i = 0; i < sortLetters1.length; i++) {

  //   }

  return sortLetters2;
}
// console.log(mix('Are they here', 'yes, they are here')); // "2:eeeee/2:yy/=:hh/=:rr"
// console.log(mix('A generation must confront the looming ', 'codewarrs')); // "1:nnnnn/1:ooooo/1:tttt/1:eee/1:gg/1:ii/1:mm/=:rr"
// console.log(mix('codewars', 'codewars')); // ''

//? ----------------------------------

/*
4 kyu
Explosive Sum

Сколькими способами можно получить сумму чисел?
Из Википедии: https://en.wikipedia.org/wiki/Partition_(number_theory)

В теории чисел и комбинаторике разбиение натурального числа n , 
также называемое целочисленным разбиением , — это способ записи n в виде суммы 
положительных целых чисел. Две суммы, отличающиеся только порядком слагаемых, 
считаются одним и тем же разбиением. Если порядок имеет значение, сумма становится 
композицией. Например, число 4 можно разделить пятью различными способами:

4
3 + 1
2 + 2
2 + 1 + 1
1 + 1 + 1 + 1
Примеры
Базовый
sum(1) // 1
sum(2) // 2  -> 1+1 , 2
sum(3) // 3 -> 1+1+1, 1+2, 3
sum(4) // 5 -> 1+1+1+1, 1+1+2, 1+3, 2+2, 4
sum(5) // 7 -> 1+1+1+1+1, 1+1+1+2, 1+1+3, 1+2+2, 1+4, 5, 2+3

sum(10) // 42
Взрывной
sum(50) // 204226
sum(80) // 15796476
sum(100) // 190569292
*/
function sum(num) {
  return 0;
}
// console.log(sum(1)) // 1
// console.log(sum(4)) // 5
// console.log(sum(10)) // 42
// console.log(sum(50)) // 204226
// ? -------------------------------------------------------
/*
4 kyu Square into Squares. Protect trees!

Учитывая положительное целое число n, вернуть строго возрастающую 
последовательность чисел (список/массив/строку в зависимости от языка) так, 
чтобы сумма квадратов была равна n².

Если решений несколько (а они будут), верните, насколько это возможно, 
результат с максимально возможными значениями:

Примеры
decompose(11)должен вернуться [1,2,4,10]. Обратите внимание, 
что на самом деле существует два способа разложить 
11²: 11² = 121 = 1 + 4 + 16 + 100 = 1² + 2² + 4² + 10², 
но не возвращать результат [2,6,9], поскольку 9 меньше 10.

For decompose(50)не возвращать [1, 1, 4, 9, 49], но [1, 3, 5, 8, 49] 
поскольку [1, 1, 4, 9, 49] не образует строго возрастающую последовательность.

Примечание
Ни то [n], ни другое не [1,1,1,…,1]являются действительными решениями. 
Если допустимого решения не существует, верните nil, null,
*/
function decompose(n) {
  // your code
}
// console.log(decompose(11)); // [1,2,4,10]
// console.log(decompose(50)); // [1, 3, 5, 8, 49]
// console.log(decompose(5)); // [3, 4]

//? -------------------------------------------------
