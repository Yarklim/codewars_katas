//? ----------------------------------------------------------
/*
5 kyu
Common Denominators

Общие знаменатели

У вас будет список рациональных чисел в виде

{ {numer_1, denom_1} , ... {numer_n, denom_n} } 
or
[ [numer_1, denom_1] , ... [numer_n, denom_n] ] 
or
[ (numer_1, denom_1) , ... (numer_n, denom_n) ] 
где все числа являются положительными целыми числами. 
Вы должны получить результат в виде:

(N_1, D) ... (N_n, D) 
or
[ [N_1, D] ... [N_n, D] ] 
or
[ (N_1', D) , ... (N_n, D) ] 
or
{{N_1, D} ... {N_n, D}} 
or
"(N_1, D) ... (N_n, D)"
в зависимости от языка (см. примеры тестов), в котором D как можно меньше и

N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.
Пример:
convertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]
Примечание:
В связи с тем, что первые переводы были написаны давно - более 6 лет 
- в этих первых переводах есть только несократимые дроби.

В более новых переводах есть некоторые сократимые дроби. 
Чтобы быть в безопасности, лучше проделать немного больше работы, упростив дроби, 
даже если это не обязательно.
*/

function convertFrac(lst) {}

// console.log(
//   convertFrac([
//     [1, 2],
//     [1, 3],
//     [1, 4],
//   ])
// ); // "(6,12)(4,12)(3,12)"

//? --------------------------------------------------------
/*
4 kyu Strings Mix

Учитывая две строки s1 и s2, мы хотим визуализировать, насколько они различаются. 
Мы будем учитывать только строчные буквы (от а до z). Сначала посчитаем частоту встречаемости каждой строчной буквы в s1 и s2.

s1 = "A aaaa bb c"

s2 = "& aaa bbb c d"

s1 has 4 'a', 2 'b', 1 'c'

s2 has 3 'a', 3 'b', 1 'c', 1 'd'

Таким образом, максимум для «a» в s1 и s2 равен 4 из s1; максимум для 'b' равен 3 от s2. 
В дальнейшем мы не будем рассматривать буквы, максимум их вхождений которых меньше или равен 1.

Мы можем возобновить различия между s1 и s2 в следующей строке: "1:aaaa/2:bbb" 
где 1 in 1:aaaa означает строку s1 и aaaa потому что максимум for aравен 4. 
Таким же образом 2:bbb обозначается строка s2 и bbb потому что максимум for bравен 3.

Задача состоит в том, чтобы создать строку, в которой каждая строчная буква s1 или s2 встречается столько раз, 
сколько ее максимум, если этот максимум строго больше 1 ; перед этими буквами будет стоять номер строки, 
в которой они встречаются, с максимальным значением и :. 
Если максимум находится в s1, а также в s2, префикс равен =:.

В результате подстроки (например, подстрока 2:nnnnn или 1:hhh; она содержит префикс) будут располагаться 
в порядке убывания своей длины, а при одинаковой длине - в возрастающем лексикографическом порядке 
(буквы и цифры - подробнее точно отсортировано по коду); разные группы будут разделены символом «/».
*/

function mix(s1, s2) {
  if (s1 === s2) return '';

  const obj1 = {};
  const obj2 = {};
  const lettersArr1 = s1.match(/[a-z]/g);
  const lettersArr2 = s2.match(/[a-z]/g);

  for (const el of s1) {
    if (lettersArr2.includes(el)) {
      if (!obj1[el]) obj1[el] = 0;
      obj1[el] += 1;
    }
  }

  for (const el of s2) {
    if (lettersArr1.includes(el)) {
      if (!obj2[el]) obj2[el] = 0;
      obj2[el] += 1;
    }
  }

  const sortLetters1 = new Array(
    ...Object.entries(obj1)
      .filter((el) => el[1] > 1)
      .sort((a, b) => b[1] - a[1])
  );
  const sortLetters2 = new Array(
    ...Object.entries(obj2)
      .filter((el) => el[1] > 1)
      .sort((a, b) => b[1] - a[1])
  );

  let result = '';

  //   for (let i = 0; i < sortLetters1.length; i++) {

  //   }

  return sortLetters2;
}
// console.log(mix('Are they here', 'yes, they are here')); // "2:eeeee/2:yy/=:hh/=:rr"
// console.log(mix('A generation must confront the looming ', 'codewarrs')); // "1:nnnnn/1:ooooo/1:tttt/1:eee/1:gg/1:ii/1:mm/=:rr"
// console.log(mix('codewars', 'codewars')); // ''

//? ----------------------------------

/*
4 kyu
Explosive Sum

Сколькими способами можно получить сумму чисел?
Из Википедии: https://en.wikipedia.org/wiki/Partition_(number_theory)

В теории чисел и комбинаторике разбиение натурального числа n , 
также называемое целочисленным разбиением , — это способ записи n в виде суммы 
положительных целых чисел. Две суммы, отличающиеся только порядком слагаемых, 
считаются одним и тем же разбиением. Если порядок имеет значение, сумма становится 
композицией. Например, число 4 можно разделить пятью различными способами:

4
3 + 1
2 + 2
2 + 1 + 1
1 + 1 + 1 + 1
Примеры
Базовый
sum(1) // 1
sum(2) // 2  -> 1+1 , 2
sum(3) // 3 -> 1+1+1, 1+2, 3
sum(4) // 5 -> 1+1+1+1, 1+1+2, 1+3, 2+2, 4
sum(5) // 7 -> 1+1+1+1+1, 1+1+1+2, 1+1+3, 1+2+2, 1+4, 5, 2+3

sum(10) // 42
Взрывной
sum(50) // 204226
sum(80) // 15796476
sum(100) // 190569292
*/
function sum(num) {
  return 0;
}
// console.log(sum(1)) // 1
// console.log(sum(4)) // 5
// console.log(sum(10)) // 42
// console.log(sum(50)) // 204226
// ? -------------------------------------------------------
/*
4 kyu Square into Squares. Protect trees!

Учитывая положительное целое число n, вернуть строго возрастающую 
последовательность чисел (список/массив/строку в зависимости от языка) так, 
чтобы сумма квадратов была равна n².

Если решений несколько (а они будут), верните, насколько это возможно, 
результат с максимально возможными значениями:

Примеры
decompose(11)должен вернуться [1,2,4,10]. Обратите внимание, 
что на самом деле существует два способа разложить 
11²: 11² = 121 = 1 + 4 + 16 + 100 = 1² + 2² + 4² + 10², 
но не возвращать результат [2,6,9], поскольку 9 меньше 10.

For decompose(50)не возвращать [1, 1, 4, 9, 49], но [1, 3, 5, 8, 49] 
поскольку [1, 1, 4, 9, 49] не образует строго возрастающую последовательность.

Примечание
Ни то [n], ни другое не [1,1,1,…,1]являются действительными решениями. 
Если допустимого решения не существует, верните nil, null,
*/
function decompose(n) {
  // your code
}
// console.log(decompose(11)); // [1,2,4,10]
// console.log(decompose(50)); // [1, 3, 5, 8, 49]
// console.log(decompose(5)); // [3, 4]

// ? ---------------------------------------------------------------

/*
5 kyu First Variation on Caesar Cipher

Действие шифра Цезаря заключается в замене каждой буквы открытого текста 
(буквы открытого текста — от «a» до «z» или от «A» до «Z») другой буквой на 
фиксированное количество позиций выше или ниже по алфавиту.

Эта программа выполняет вариацию сдвига Цезаря. Сдвиг увеличивается на 1 для каждого символа 
(на каждой итерации).

Если изначально сдвиг равен 1, то первый символ кодируемого сообщения будет сдвинут на 1, 
второй символ будет сдвинут на 2 и т. д.

Кодирование: Параметры и возврат функции "movingShift"
param s: строка для кодирования

параметр shift: целое число, дающее начальный сдвиг

Функция «movingShift» сначала кодирует всю строку, а затем возвращает массив строк, 
содержащий закодированную строку в пяти частях (пяти частях, потому что во избежание 
дополнительных рисков закодированное сообщение будет передано пяти бегунам, по одной части 
на каждого бегуна).

Если возможно, сообщение будет поровну разделено по длине сообщения между пятью участниками. 
Если это невозможно, части с 1 по 5 будут иметь последовательно невозрастающую длину, 
так что части с 1 по 4 будут как минимум такими же длинными, как при равномерном разделении, 
но как максимум на 1 длиннее. Если последняя часть является пустой строкой, 
эта пустая строка должна быть показана в результирующем массиве.

Например, если длина закодированного сообщения составляет 17, то пять частей будут иметь 
длину 4, 4, 4, 4, 1. Части 1, 2, 3, 4 делятся поровну, а последняя часть длины 1 короче. 
Если длина составляет 16, то части будут иметь длину 4, 4, 4, 4, 0. Части 1, 2, 3, 
4 делятся поровну, и пятый бегун останется дома, так как его часть — пустая строка. 
Если длина составляет 11, то равные части будут иметь длину 2,2, поэтому части будут 
иметь длину 3, 3, 3, 2, 0.

Вы также реализуете функцию «demovingShift» с двумя параметрами.

Декодирование: параметры и возврат функции "demovingShift"
массив строк: s (возможно, полученный в результате «movingShift», с 5 строками)

сдвиг int

«demovingShift» возвращает строку.

Пример:
u = "Я должен был знать, что у тебя найдется для меня идеальный ответ!!!"

movingShift(u, 1)возвращает:

v = ["J vltasl rlhr", "zdfog odxr ypw", "atasl rlhr p", "gwkzzyq zntyhv", "lvz wp!!!"]

(кавычки добавлены для того, чтобы видеть строки и пробелы, ваша программа не будет 
записывать эти кавычки, см. Примеры тестовых случаев)

и demovingShift(v, 1)возвращает u. #Ref:
*/
function movingShift(s, shift) {
  let newString = '';

  for (let i = 0; i < s.length; i++) {
    const char = s[i];
    const effectiveShift = shift + i;

    if (char >= 'a' && char <= 'z') {
      const code = char.charCodeAt(0) - 97;
      const newCode = (code + effectiveShift) % 26;

      newString += String.fromCharCode(newCode + 97);
    } else if (char >= 'A' && char <= 'Z') {
      const code = char.charCodeAt(0) - 65;
      const newCode = (code + effectiveShift) % 26;

      newString += String.fromCharCode(newCode + 65);
    } else {
      newString += char;
    }
  }

  const strPartLength = Math.floor(newString.length / 5);
  const result = [
    newString.slice(0, strPartLength + 1),
    newString.slice(strPartLength + 1, strPartLength * 2 + 2),
    newString.slice(strPartLength * 2 + 2, strPartLength * 3 + 3),
    newString.slice(strPartLength * 3 + 3, strPartLength * 4 + 4),
    newString.slice(strPartLength * 4 + 4),
  ];

  return result;

  // A - 65, Z - 90
  // a - 97, z - 122 expected [ ' xscOpz', 'vygqAft', 'uwudada', 'xmhEdqr', 'ut' ] to deeply equal [ ' xscOp', 'zvygqA', 'ftuwud', 'adaxmh', 'Edqrut' ]
}

function demovingShift(arr, shift) {
  const str = arr.join('');
  let result = '';

  for (let i = 0; i < str.length; i++) {
    const ch = str[i];
    const effectiveShift = shift + i;

    if (ch >= 'a' && ch <= 'z') {
      const code = ch.charCodeAt(0) - 97;
      const newCode = (((code - effectiveShift) % 26) + 26) % 26;
      result += String.fromCharCode(newCode + 97);
    } else if (ch >= 'A' && ch <= 'Z') {
      const code = ch.charCodeAt(0) - 65;
      const newCode = (((code - effectiveShift) % 26) + 26) % 26;
      result += String.fromCharCode(newCode + 65);
    } else {
      result += ch;
    }
  }

  return result;
}

// console.log(
//   movingShift(
//     'I should have known that you would have a perfect answer for me!!!',
//     1
//   )
// );
// // "J vltasl rlhr ", "zdfog odxr ypw", " atasl rlhr p ", "gwkzzyq zntyhv", " lvz wp!!!"
// console.log(
//   demovingShift([' xscOp', 'zvygqA', 'ftuwud', 'adaxmh', 'Edqrut'], 1)
// );

//? -------------------------------------------------
